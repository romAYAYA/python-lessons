# TODO Binary search

def binary_search(list, item):  # В low и high хранятся границы той части списка, в которой выполняется поиск
    low = 0
    high = len(list) - 1

    while low <= high:
        mid = (low + high)  # Пока эта часть не сократится до одного элемента проверяем средний элемент
        guess = list[mid]

        if guess == item:  # Значение найдено
            return mid

        if guess > item:  # Много
            high = mid - 1

        else:  # Мало
            low = mid + 1
    return None  # Значение не существует


my_list = [1, 2, 5, 6, 3, 8, 3]

print(binary_search(my_list, 2))  # 1

# Имеется отсортированный список из 128 имен, и вы ищете в нем значение методом бинарного поиска.
# Какое максимальное количество проверок для этого может потребоваться?
# Ответ: 7. 128-64-32-16-8-4-2-1

# Предположим, размер списка увеличился вдвое. Как изменится максимальное количество проверок?
# Ответ: 8. 256-128-64-32-16-8-4-2-1

# "О-большое" определяет время выполнения в худшем случае

# O(n) линейный поиск (линейная сложность)
# O(log n) бинайрный поиск (логарифмическая сложность)

# Скорость алгоритмов измеряется не в секундах, а в темпе роста количества операции.
# По сути формула описывает, насколько быстро возрастает время выполнения алгоритма с увеличением размера входных данных.
# Время выполнения алгоритмов выражается как O-большое.
# Бремя выполнения O(log n) быстрее О(n), а с увеличением размера списка, в котором ищется значение, оно становится намного быстрее.